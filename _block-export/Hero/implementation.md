# BLOCK IMPLEMENTATION INSTRUCTIONS (for Cursor AI)

You are Cursor AI.  
You are currently inside a block folder that was generated by the block extraction process and then manually placed into a **target AEMaaCS/EDS project**.

Your job is to **integrate this block into the target project**, using the extracted JS, CSS, JSON, and documentation that exist inside this folder.

This file is **fully interactive**.  
If you do not have enough information, you must **ask the user questions first** and wait for answers.  
After receiving answers, **restart the execution of this file from the beginning**.

---

# 0. ENVIRONMENT VALIDATION (MANDATORY)

Before you do anything, you must validate:

1. **That this file is located inside a `_block-export/` folder within a project**
2. **That the required extracted files/folders exist**
3. **That the surrounding project appears to be an AEM Edge Delivery Services (EDS) project**

If any of these checks fail → **STOP immediately**, explain the issue, and ask the user to correct it.

---

## 0.1 Validate folder location

Verify that:

- The current directory path includes:  
  `/_block-export/`  
  Example:  
  `/target-project/_block-export/Article-Header/IMPLEMENTATION.md`

If `_block-export/` is not in the path:

> ERROR: This IMPLEMENTATION.md file must be placed in a folder under `/_block-export/` inside the target project.  
> Current path appears incorrect.  
> Please place this extracted block folder inside your target repository and try again.

(Stop execution until user fixes the placement.)

---

## 0.2 Validate required extracted contents

Inside this folder, ensure the minimum required contents exist:

Required files (at least one of each type):

- `.js` or `.ts` files (JavaScript/TypeScript)
- `.css` or `.scss` files (Stylesheets)
- `.json` files (Models/Configuration)

Optional but recommended:

- `extraction-information.md`
- `summary.md`
- `description.md`

All files should be located directly in the root of `LIBRARY_BLOCK_FOLDER_NAME`, not in subfolders.

If no files of the required types are found:

> ERROR: Missing required files: [JS/TS, CSS/SCSS, or JSON files].  
> This block cannot be implemented until all required file types exist.  
> Please ensure the extraction was done correctly.

Stop execution and ask the user how they want to proceed.

---

## 0.3 Validate that the target repository is an EDS project

Check the folder structure *outside* this `_block-export` directory.

Look for at least one of the following:

- A `/blocks/` directory  
- A `/models/` directory  
- A `/styles/` or `/styles/blocks/` directory  
- EDS config files (any of the following):  
  - `fstab.yaml`  
  - `helix-config.yaml`  
  - `helix-query.yaml`  
  - `package.json` references to Adobe/Franklin/EDS tools

If **none** of these exist:

> ERROR: This repository does not appear to be an EDS project.  
> I was expecting to find directories such as `/blocks/`, `/models/`, or EDS config files.  
> Please confirm that this is an EDS project before continuing.

Stop and ask the user for clarification.

---

# 1. GATHER USER INPUT (MANDATORY)

Before performing any file operations, ask the user for:

> Before I start implementing this block into your project, I need a few details:
>
> **1. What should this block be named in this project?**
> - If it is a single block, provide:  
>   `TARGET_BLOCK_NAME` (e.g. `article-header`)
> - If it is a parent/child pair (e.g. container + item), provide:  
>   `PARENT_BLOCK_NAME` and `CHILD_BLOCK_NAME`
>
> **2. Where is the global model/registration file?**  
> - Path to global registration file (e.g. `/models/_section.json`)
>
> **3. Any naming conventions or project rules I should follow?**

Wait for the user's reply.

Store:

- `TARGET_BLOCK_NAME` **or** (`PARENT_BLOCK_NAME`, `CHILD_BLOCK_NAME`)
- `GLOBAL_MODEL_PATH`
- `BLOCK_INDEX_PATH` (optional)

**Note:** Files will automatically be placed in this block's dedicated folder:
- JS/TS files: Create and populate `Blocks/TARGET_BLOCK_NAME/` (or separate folders for parent/child blocks)
- CSS/SCSS files: Place in the same `Blocks/TARGET_BLOCK_NAME/` folder alongside JS files
- JSON/Models: Merge this block's model into `GLOBAL_MODEL_PATH`

**Each block gets its own isolated folder. Do not mix files from different blocks.**

Repeat back to the user to confirm correctness before continuing.

If unclear → explain the issue and ask again.

---

# 2. READ EXTRACTION METADATA AND NAMING MAP (MANDATORY)

## 2.1 Read extraction metadata

If the file `extraction-information.md` exists:

- Read original block name (`SOURCE_BLOCK_NAME`)
- Read any notes about dependencies, naming, or custom folder structures
- Use it to guide renaming and conflict resolution

If the file does not exist, proceed without it but mention this in the final summary.

## 2.2 Read naming map (CRITICAL)

The file `naming-map.json` is **MANDATORY** and contains:
- The placeholder scheme used during extraction
- All patterns that need to be replaced
- Original naming conventions

**Read `naming-map.json` and understand:**

1. **Block type:** Is this a single block or parent/child pattern?

2. **Placeholder patterns used:**
   - `{BLOCK_NAME}` - in file names and kebab-case references
   - `{BLOCK_CLASS}` - in CSS classes and kebab-case strings
   - `{BLOCK_FUNC}` - in PascalCase function names
   - `{BLOCK_VAR}` - in camelCase variable names
   - For parent/child: `{PARENT_BLOCK_NAME}`, `{CHILD_BLOCK_NAME}`, etc.

3. **What needs to be replaced:**
   - File names containing placeholders
   - CSS selectors and class names
   - JavaScript function and variable names
   - Import/export statements
   - String literals in code

If `naming-map.json` is missing:
> ERROR: The `naming-map.json` file is missing.  
> This file is required to properly rename the block during implementation.  
> The extraction may have been incomplete. Please re-extract the block or create the naming map manually.

Stop execution until resolved.

---

# 3. DERIVE TARGET NAMES FROM USER INPUT (MANDATORY)

Based on the user's input from Step 1, automatically derive all necessary naming variations:

## 3.1 For single blocks:

If user provided: `TARGET_BLOCK_NAME = "my-custom-header"`

Automatically generate:
- **File/folder name (kebab-case):** `my-custom-header`
- **CSS class prefix (kebab-case):** `my-custom-header`
- **Function name (PascalCase):** `MyCustomHeader`
- **Variable name (camelCase):** `myCustomHeader`

## 3.2 For parent/child blocks:

If user provided: 
- `PARENT_BLOCK_NAME = "product-carousel"`
- `CHILD_BLOCK_NAME = "product-card"`

Automatically generate:

**Parent:**
- File/folder: `product-carousel`
- CSS class: `product-carousel`
- Function: `ProductCarousel`
- Variable: `productCarousel`

**Child:**
- File/folder: `product-card`
- CSS class: `product-card`
- Function: `ProductCard`
- Variable: `productCard`

## 3.3 Confirm with user

Display the derived names and ask for confirmation:

> I will use these names for your block:
>
> **File names:** `my-custom-header.js`, `my-custom-header.css`
> **CSS classes:** `.my-custom-header`, `.my-custom-header__element`, `.my-custom-header--modifier`
> **JS functions:** `MyCustomHeader()`, `decorateMyCustomHeader()`
> **JS variables:** `myCustomHeader`, `myCustomHeaderConfig`
>
> If this looks correct, I will proceed with the replacement.
> If you need different naming patterns, please specify them now.

Wait for user confirmation before proceeding.

---

# 4. REPLACE ALL PLACEHOLDERS IN EXTRACTED FILES (CRITICAL)

**Before copying any files to the target project, replace all placeholders:**

## 4.1 Create replacement mapping

From the user-confirmed names, create a replacement map:

```javascript
{
  "{BLOCK_NAME}": "my-custom-header",
  "{BLOCK_CLASS}": "my-custom-header",
  "{BLOCK_FUNC}": "MyCustomHeader",
  "{BLOCK_VAR}": "myCustomHeader"
}
```

For parent/child blocks:

```javascript
{
  "{PARENT_BLOCK_NAME}": "product-carousel",
  "{PARENT_CLASS}": "product-carousel",
  "{PARENT_FUNC}": "ProductCarousel",
  "{PARENT_VAR}": "productCarousel",
  "{CHILD_BLOCK_NAME}": "product-card",
  "{CHILD_CLASS}": "product-card",
  "{CHILD_FUNC}": "ProductCard",
  "{CHILD_VAR}": "productCard"
}
```

## 4.2 Replace in file names

1. Scan all files in the extracted folder
2. Rename files containing placeholders:
   - `{BLOCK_NAME}.js` → `my-custom-header.js`
   - `{BLOCK_NAME}.css` → `my-custom-header.css`
   - `{PARENT_BLOCK_NAME}.js` → `product-carousel.js`
   - `{CHILD_BLOCK_NAME}.js` → `product-card.js`

## 4.3 Replace in file contents

For each file (JS, CSS, JSON):

1. **Read the entire file content**
2. **Apply all placeholder replacements** using the mapping from 4.1
3. **Write the updated content back**

**Important replacement order:**
- Replace longer placeholders first to avoid partial replacements
- Example: Replace `{PARENT_BLOCK_NAME}` before `{BLOCK_NAME}`

## 4.4 Validate replacements

After all replacements:

1. **Check for remaining placeholders:**
   - Search all files for any remaining `{` and `}` patterns
   - If found, report them to the user

2. **Verify syntax:**
   - Ensure JS/TS files still have valid syntax
   - Ensure CSS files still have valid syntax
   - Report any syntax errors

3. **Log replacements:**
   - Count total replacements made
   - List files that were modified
   - Save this information for the final summary

If validation fails:
> ERROR: Placeholder replacement failed validation.
> - Files with remaining placeholders: [list]
> - Syntax errors found: [list]
>
> Please review these issues before continuing.

Stop and ask user how to proceed.

---

# 5. COPY JS/TS FILES INTO THE TARGET PROJECT

From the root of this extracted block folder:

- Identify all `.js` and `.ts` files (look for files with `.js`, `.ts`, `.jsx`, `.tsx` extensions).
- **These files should now have real names (no placeholders) after Step 4.**

Copy them to **this block's specific folder** within the `Blocks/` structure:

- **Standalone block:**  
  Create folder: `Blocks/TARGET_BLOCK_NAME/`  
  Copy JS/TS files into: `Blocks/TARGET_BLOCK_NAME/`
  Example: `Blocks/my-custom-header/my-custom-header.js`

- **Parent/Child pattern:**  
  Create folders: `Blocks/PARENT_BLOCK_NAME/` and `Blocks/CHILD_BLOCK_NAME/`  
  Copy parent JS files into: `Blocks/PARENT_BLOCK_NAME/`  
  Copy child JS files into: `Blocks/CHILD_BLOCK_NAME/`
  Example: `Blocks/product-carousel/product-carousel.js` and `Blocks/product-card/product-card.js`

**Important:** 
- All placeholders should already be replaced with actual names from Step 4
- Only copy files for THIS specific block
- Do not modify or copy files from other blocks

If missing utilities exist, list them in the final report instead of inventing them.

---

# 6. COPY CSS/SCSS FILES INTO THE TARGET PROJECT

From the root of this extracted block folder:

- Identify all `.css` / `.scss` files (look for files with `.css`, `.scss`, `.sass` extensions).
- **These files should now have real names and real CSS classes (no placeholders) after Step 4.**

Copy them to **this block's specific folder** within the `Blocks/` structure:

  - **Standalone block:**  
    Copy CSS files into: `Blocks/TARGET_BLOCK_NAME/`  
    Example: `Blocks/my-custom-header/my-custom-header.css`
  
  - **Parent/Child pattern:**  
    Copy parent CSS into: `Blocks/PARENT_BLOCK_NAME/`  
    Copy child CSS into: `Blocks/CHILD_BLOCK_NAME/`  
    Example: `Blocks/product-carousel/product-carousel.css` and `Blocks/product-card/product-card.css`

**Important:** 
- All placeholders should already be replaced with actual names and CSS classes from Step 4
- Only copy CSS files for THIS specific block
- Do not modify or copy files from other blocks

If the project uses a central SCSS importer, mention it in the summary for manual update.

---

# 7. REGISTER MODEL / CONFIG FILES

From the root of this extracted block folder:

- Identify all `.json` files (look for files with `.json` extension).
- **These files should now have real block names (no placeholders) after Step 4.**
- Merge block models into the project's main config at:  
  `GLOBAL_MODEL_PATH` (typically `/models/_section.json` or similar)

Behavior:

- If global file is an array → append block definition
- If global file is an object → add new keys
- Maintain formatting
- Follow naming conventions used by other blocks
- Use block names that match the folder names in `Blocks/`

**Note:** The block paths in the JSON should reference:
- `Blocks/TARGET_BLOCK_NAME` for single blocks
- `Blocks/PARENT_BLOCK_NAME` and `Blocks/CHILD_BLOCK_NAME` for parent/child blocks

If unclear, ask the user to confirm how the JSON should be structured.

---

# 8. UPDATE BLOCK INDEX / ROUTER (OPTIONAL)

If `BLOCK_INDEX_PATH` exists:

- Add imports for the new block(s) using the actual block names from Step 4
- Add export or routing entries following existing patterns

If index file does not exist → mention this in summary (not an error).

---

# 9. SANITY CHECKS

After copying and wiring:

- Check for remaining placeholders (any `{BLOCK_NAME}`, `{BLOCK_CLASS}`, etc.)
- Report unresolved imports  
- Check for any syntax errors in copied files
- Verify all file paths are correct and files exist

---

# 10. RUN TESTS (IF NO ISSUES FOUND)

If all sanity checks pass and no critical issues were found during implementation, run the following tests:

## 8.1 Build/Compile Test

Run the project's build command to ensure no compilation errors:

```bash
# Common EDS/AEM build commands (run the appropriate one for this project)
npm run build
# or
npm run lint
# or
aem up
```

If build fails:
- Report the exact error
- Identify which file is causing the issue
- Suggest fixes but do not modify without user confirmation

## 10.2 Development Server Test (Optional)

If the build succeeds, offer to start the development server:

```bash
# Common dev server commands
npm run dev
# or
npm start
# or
aem up
```

Then inform the user:

> Development server started successfully.
> You can now test the block at: [provide URL if known, typically http://localhost:3000]
>
> To test the block:
> 1. Navigate to a page that uses this block
> 2. Verify the block renders correctly
> 3. Check browser console for any errors
> 4. Test responsive behavior

## 10.3 Linting Test

Run linting to check code quality:

```bash
npm run lint
# or
npm run lint:fix  # to auto-fix issues
```

Report any linting errors or warnings found.

---

# 11. CLEANUP - DELETE TEMPORARY EXTRACTION FOLDER

**ONLY proceed with cleanup if:**
- All tests passed successfully (build, linting)
- Block is confirmed working in the target repository
- User confirms they are ready to clean up

Before deleting, ask the user for confirmation:

> All implementation steps completed successfully!
>
> The block has been integrated into your project at:
> - `Blocks/TARGET_BLOCK_NAME/` (with all JS, CSS files)
> - Models registered in: `GLOBAL_MODEL_PATH`
>
> **Ready to clean up?**
> 
> I can now delete the temporary extraction folder:
> - `_block-export/[BLOCK_FOLDER_NAME]/`
> 
> This will remove:
> - All extracted files (JS, CSS, JSON, docs)
> - `extraction-information.md`
> - `summary.md`
> - This `IMPLEMENTATION.md` file itself
>
> The block will remain fully functional in `Blocks/TARGET_BLOCK_NAME/`.
>
> **Should I proceed with cleanup?** (yes/no)

Wait for user confirmation.

## 11.1 If User Confirms Cleanup

Delete the entire `_block-export/[BLOCK_FOLDER_NAME]/` directory:

```bash
# Example command (adjust path based on actual location)
rm -rf _block-export/[BLOCK_FOLDER_NAME]
```

**After deletion, inform the user:**

> ✅ Cleanup completed successfully.
>
> **Deleted:**
> - `_block-export/[BLOCK_FOLDER_NAME]/` (entire folder including naming-map.json)
>
> **Preserved:**
> - `Blocks/TARGET_BLOCK_NAME/` - Your block is live here with your chosen names
> - `GLOBAL_MODEL_PATH` - Models registered
> - All project files intact
>
> The block is now fully integrated and the temporary files have been removed.

## 11.2 If User Declines Cleanup

> No problem! The temporary folder will remain at:
> - `_block-export/[BLOCK_FOLDER_NAME]/`
>
> You can delete it manually later when ready, or keep it for reference.
> The block is already fully functional in `Blocks/TARGET_BLOCK_NAME/`.

---

# 12. FINAL SUMMARY TO USER

After all steps (including tests and cleanup), respond with something like:

> Implementation completed.  
>
> **Block Names:**  
> - Original source name: [SOURCE_BLOCK_NAME from naming-map.json]
> - Implemented as: [TARGET_BLOCK_NAME or PARENT/CHILD names]  
>
> **Naming Replacements:**
> - Total placeholders replaced: [count]
> - File names updated: [list]
> - CSS classes renamed: [examples]
> - JS functions renamed: [examples]
>
> **Files Created:**  
> - JS files in: `Blocks/[block-name]/` - [list files]  
> - CSS files in: `Blocks/[block-name]/` - [list files]  
> - JSON/Model entries updated in: `GLOBAL_MODEL_PATH`
>
> **Files Modified:**  
> - `GLOBAL_MODEL_PATH` (model/config registration)
> - `BLOCK_INDEX_PATH` (if block index was updated)  
>
> **Standard Structure Used:**  
> - All block files placed in: `Blocks/TARGET_BLOCK_NAME/` (or `Blocks/PARENT_BLOCK_NAME/` and `Blocks/CHILD_BLOCK_NAME/`)
>
> **Test Results:**  
> - Build: ✅ Passed / ❌ Failed (with details)
> - Linting: ✅ Passed / ⚠️ Warnings (with details)
> - Dev Server: ✅ Started / ⏭️ Skipped
>
> **Cleanup:**  
> - Temporary extraction folder: ✅ Deleted / ⏭️ Kept (user choice)
>
> **Potential TODOs:**  
> - Verify design visually in the browser
> - Ensure missing utilities are implemented  
> - Add CSS imports if required by project convention  
> - Test block functionality and responsive behavior
> - Check accessibility compliance
>
> Let me know if you want me to create a test page or need help debugging any issues.

If any step cannot proceed → stop, explain, ask for clarification.

---
